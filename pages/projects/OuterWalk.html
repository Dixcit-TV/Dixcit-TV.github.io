<header class="mb-4">
	<h2 class="tm-text-shadow">The Outer Walk - <i><small><a href="https://github.com/Dixcit-TV/The-Outer-Walk" target="_blank">Github</a></small></i></h2>
	<div class="TechIconList"> 
		<img src="../../img/CPP_Icon.png" title="C++" alt="C++"/>
		<img src="../../img/DX11_Icon.png" title="DirectX 11" alt="DirectX 11"/>
		<img src="../../img/Physx_Icon.png" title="NVidia Physx" alt="NVidia Physx"/>
	</div>
</header>
<div class="VideoContent">
	<iframe width="560" height="315" src="https://www.youtube.com/embed/TT7pnFtVSV8" title="The Outer Walk trailer" frameborder="0" 
		allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>
<div class="ProjectArticle">
	<h3 class="tm-text-shadow">Introduction</h2>
	<p class="mb-5">For Graphics Programming 2, after a semester of learning and implementing environment & normal mapping, phong & diffuse shading, shadow mapping, animation, particles, and basics of DX11 and the Physx API, we are tasked to create a vertical slice of a pre-existing or totally invented game. I then dicided to come up with my own idea: The Outer Walk.</p>
	
	<p class="mb-5">Over implementing a proper game level (like Bomberman, Overcooked-like, Prince of persia, etc...) with a begining and end, I wanted to focus on shaders and working with the GPU to learn by practicing. I am a big fan of procedural generation and I recently came accross a videos and resources about procedural planet generation that seemed like a really interesting challenge. The final result being a real-time planet generator using an IMGUI menu to control the generation parameters.</p>
	
	<h3 class="tm-text-shadow">The sphere generation</h3>
	
	<p class="mb-5">Many ways can be found online to generate a sphere triangle mesh procedurally with variable tesselation; UV-sphere, Cube-sphere, Ico-sphere. I had to pick one for my endeavor and the Ico-spehere seemed like a pretty good candidate as the base Icosahedron mesh allows for a (relatively) even distribution of triangles after tesselation, triangles that are (almost) equilateral.<br/>
	Now that I had a starting shape, I needed to decide on a tesselation "algorithm". Considering 4 other courses on the side and a little over a month left, I decided to kill 2 birds (lack of time + new knowledge) with one stone and dive into the tesselation shader stage available in DX11 pipeline.<br/>
	DX11 tesselation stage allows to define a the edge and inner subdivision per triangle, I found out that subdividing the edge and inner triangle by the same number result in the "even distribution" I was looking for. From there, what I needed was to bind my tesselation vertex list ouput to a vertex buffer to use for rendering in a future pass. One draw-back I discovered from using the tesselation shader was the tesselation level limited to 64 subdisions, but it was definetly good enough for my experimentation.</p>
	
	<h3 class="tm-text-shadow">The landscape generation</h3>
	
	<p class="mb-5">I had my sphere, the next step was to generate the landmass and oceans. A very common way to do so is by using noise and more specifically Perlin and Simplex noise due to their "smooth gradient" nature. Using a HLSL implementation of a simplex noise function, I created several noise layers that would each generate a different aspect of my planet terrain; a layer for the main land shape, one for the overal detailing and a final one for the mountains. Each layers are then added on top of each other to form the final planet. All this being done in the domain shader of our tesselation stage.</p>
	
	<h3 class="tm-text-shadow">Shading & shadows & ocean</h3>
	
	<p class="mb-5">The final step was to add some shading to this grey planet. For this I stored each vertices height and steepness. I the used those values to blend shore, land and mountains colors together and try to give the planet a natural look. Shadows were added using shadow mapping. And as a final touch, followed  the idea to create my "oceans" shading as a post processing effect that is traced on top of the final planet mesh, with waves added with triplanar normal mapping.</p>
	
	<h3 class="tm-text-shadow">Resources</h3>
	
	<ul>
		<li>
			"3D Game Programming with DirectX11" by Frank D. Luna
		</li>
		<li>
			Simplex noise library for HLSL: <a href="https://forum.unity.com/threads/2d-3d-4d-optimised-perlin-noise-cg-hlsl-library-cginc.218372/" target="_blank">Unity Forum<a/> (I cannot find again the exact Github repo but it was based on this article)
		</li>
		<li>
			Depth to viewSpace: <a href="https://mynameismjp.wordpress.com/2009/03/10/reconstructing-position-from-depth/" target="_blank">mynameismjp.wordpress.com<a/>
		</li>
		<li>
			Coding Adventure: Procedural Moons and Planets: <a href="https://www.youtube.com/watch?v=lctXaT9pxA0" target="_blank">Youtube<a/>
		</li>
		<li>
			Triplanar mapping & normal map: <a href="https://bgolus.medium.com/normal-mapping-for-a-triplanar-shader-10bf39dca05a" target="_blank">bgolus.medium.com<a/>
		</li>
	</ul>
</div>